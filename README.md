<p align="center">
  <a href="" rel="noopener">
 <img width=200px height=200px src="https://smsmagic-13d6c.kxcdn.com/wp-content/uploads/2021/01/Shorten-URL-1024x635.png" alt="URL shortening service"></a>
</p>

<h3 align="center">URL Shortening Service</h3>

---

<p align="center"> <b>Let's design a servicefor shortening the uniform resource locator (URL)</b>
    <br> 
   URL shortening is a service that produces short aliases for long URLs, commonly referred to as short links. Upon trigger, these short links direct to the original URLs.
</p>

## üìù Table of Contents

- [About](#about)
- [System Design](#system_design)
- [Getting Started](#getting_started)
- [Usage](#usage)
- [Folder/File Structure](#folder/file_structure)
- [Built Using](#built_using)
- [Demo Link](#demo_link)
- [Candidate](#candidate)
- [Acknowledgments](#acknowledgement)

## üßê About <a name = "about"></a>

<p>In this application, we'll use <b>Flask</b> with <b>Python</b> to create a URL shortener. The service takes any given URL and generates a shorter, more readable version. To spice things up, the app lets users enter a URL and an optional custom short key, and generates a shorter version accordingly.
</p>
### Advantages
 
The key advantages of a URL shortening service are:
 
<ul>
<li>
Shortened URLs are convenient to use: they optimize link usage across different forms of devices due to their enhanced accessibility and non-breakability.
</li>
<li>They are visually professional and engaging and facilitate a higher degree of sharing possibilities.</li>
<li>They are less error-prone while typing.</li>
<li>They require smaller storage space at the user‚Äôs end.</li>
</ul>
 
### Disadvantages
The URL shortening service has some associated drawbacks as well. Some of them are as follows:
 
<ul>
<li>
We lose the originality of our brand. Many brands using the same service get short URLs containing the same domain.
</li>
<li>The possibility of it getting shut down and wiping all our shortened URLs will always be there.</li>
</ul>
 
## üöÄ System Design <a name = "system_design"></a>
 
Before jumping into development, we took the time to focus on the <b>Requirements</b> [<i>the functional and non-functional requirements</i>], for more clarity, it is better to have realistic estimations at the start. For instance, we don't have a lot to tell at this point but we are willing to learn more in depth about it. Yet we recongnize the importance of this step for the future of the service, from Storage estimation, to Query rate estimation, Bandwidth estimation, then Memory estimation, to finally estimate the Number of Servers. According to this challenge we were asked to not persist short URLs to a database. and just keep them in memory. For that reason, we will be using Hashmap to store in the memory, which is the most accurate and efficient data structure in this case.
Next, to fill up the whole big picture, more explanation about the <b>Design</b> should take place, to check the endpoints and the data flow between components. In case we are escalating, we can always return and adjust it from there.
Now, we can dive deeper, through the inner mechanism of the <b>Encode</b>, stating the reason we use it along with the mathematical explanation. Finally, we can reflect on all of that with a <b>conclusion</b> and add the area of improvement.<br>
<i>Funny but honest fact, it is my first time working on web development using Python, I usually use python for coding, data structures and Algorithms and creating notebook for machine learning and research purpose. Yet, I enjoyed every second working on this project and walking through the System design phase helped me a lot implementing the solution, which will be always open to improvement.</i><br>
Now let's drive into details:
### Requirements of shortening service
#### Functional requirements
<ul>
<li><b>Generate Short URL</b>: From an Original URL, generate a unique shorter key to create a shorter URL. </li>
<li><b>Reverse</b>: Given a short link, our system should return the Original URL.</li>
<li><b>Custom short links</b>: Users should be able to generate custom short links by giving a custom key.</li>
<li><b>Update short links</b>: After getting a generated short URL from our service, users can update their short links by giving a custom key.</li>
<li><b>Deletion</b>: Once the short link is updated, our service frees the memory to avoid confusion and wasted space due to duplication.</li>
</ul>

#### Non-functional requirements

<ul>
<li><b>Availability</b>: Our system should be highly available. </li>
<li><b>Scalability</b>: Our system should be horizontally scalable with increasing demand.</li>
<li><b>Readability</b>: The short links generated by our system should be easily readable, distinguishable, and typeable.</li>
<li><b>Latency</b>: The system should perform at low latency to provide the user with a smooth experience.</li>
<li><b>Unpredictability</b>:  From a security standpoint, the short links generated by our system should be highly unpredictable. </li>
</ul>

### Design

#### System APIs

To expose the functionality of our service, we can use REST APIs for the following endpoints:
/encode
/decode

##### Encode

To encode the original URL and create a unique short one, we sent a POST request with body containing:

<ul>
<li><b>‚Äúlong_url‚Äù-Required</b>: The original long URL that is needed to be shortened.</li>
<li><b>‚Äúcustom_id‚Äù-Optional</b>: The optional key that the user defines as a customer short key for the new URL.</li>
</ul>
<p>
A successful insertion returns a JSON with the shortened URL. If the input URL already stored but we got a custom_id as an input, here is when a user try to update the stored generated Short URL. In this case, we update the corresponding Short URL and Delete this old one. Otherwise, the system returns an appropriate error code to the user.
</p>

##### Decode

To decode a short URL and get the original one, we sent a GET request with body containing:

<ul>
<li><b>‚Äúshort_url‚Äù-Required</b>: The original long URL that is needed to be shortened.</li>
</ul>
<p>
A successful request returns a JSON with the original URL. Otherwise, the system returns an appropriate error code to the user.
</p>

#### Work flow

Let‚Äôs analyze the system in-depth and how the individual pieces fit together to provide the overall functionality.<br>
Keeping in view the functional requirements, the workflow of the abstract design above would be as follows.

<ol>
<li>
<b>Encode</b>: Each new request for short link computation checks the storage units (caching system and database or the dictionary storage in our case) .
If the input exists already two cases raise:<br>
If the custom_key is not empty, update the associated short_url accordingly and delete the old one. Else, just return the existing short_url associated to the original URL.<br>
Else, generate a random key to create a unique short url for the input URL. Upon successful generation of the short link, the system sends one copy back to the user and stores the record in the database for future use.<br>
<i>In our case we store it to a hashmap with long_url as key and the generated_short_url as a value. For future use we should also store the generated/cutom_key as a key in another hashmap with the original_url as a value.
</i>

<li>
<b>Custom short links</b>: This task begins with checking the system about its availability in the database. If the requested cutom_key doesn‚Äôt exist, the user receives a successful response with a short URL with their custom key, or an error message in the opposite case depend on the situation.
</li>

<li>
<b>Decode</b>: Upon receiving the decode request, check the storage units (caching system and database/ in our case, we check the hashmap with the generated/custom key as key and the original url as a value) for the required record of the short url. If found, the application server returns the associated original URL. Or an error message in the opposite case depend on the situation.<br>
<i>Here we need the second hashmap with generated/cutom_ key as a key and the original_url as a value. The access/search will cost less.-O(1) for time complexity.</i>
</li>

### Encode

The main functionality of our service is to generate a unique key to create a short URL. The encoding choice is so important to check on some of the non-functional requirements mentioned above such as <b>Readability</b>, and <b>Unpredictability</b>.<br>
The number of characters of the key should always be updated according to the clients‚Äô needs.<br>
Base-64 is the most common encoding for alphanumeric strings' generation. However, the generated short URL might have readability issues because of look-alike characters, and characters like + and / should be avoided because of other system-dependent encodings.
Since we don‚Äôt have any restriction about how we can encode, we can go with using Python‚Äôs random module and in-built string module for letters(lower and upper) and digits.

### Conclusion

Our service is an effective service with multiple advantages. Our design is simple, yet it fulfills all the requirements of a performant design and production-ready.<br>
The point here is that url security/predictability is not very important. Collision detection is important, and our service we ensure that by randomizing generated values ‚Äã‚Äãand check its existence for uniqueness. The key features offered by our design are:

<ul>
<li>A dynamic short URL range.</li>
<li>Improved readability.</li>
<li>Ensure uniqueness.</li>

</ul><br>

<b>Area of improvement</b>:<br>
Our service uses an in-memory dictionary to represent all shortened URLs. In a real large-scale scenario, something more outlandish will be required. This also affects the way we determine if a hash is unique. There are other room of improvement such as:

<ul>
<li> More restriction on the custom_key suggested by the users to avoid special characters, and confusing Links.</li>
<li> Upgrade the encoding method to ensure security by adding the user_id which is private and unique as encoding key for example; that we can use with other Encoding Algorithm such as md5.</li>
<li> Add more control on the generated short URL, that must always be shorter or equal than the original one. It won't be a shortening service if we will give a taller "short_url".</li>
<li>...Always open to improve and escalate according to the business and clients/users needs.</li>
</ul>

## üèÅ Getting Started <a name = "getting_started"></a>

These instructions will get you a copy of the project up and running on your local machine for development and testing purposes. To settle in the app directory:

```
cd APP
```

### Prerequisites

To install and run our shortening service, make sure you have Python3 installed, we also need Flask.

### Installing

To get a development env running, you should install the requirements. Before that we must create a virtual enviorment, let's name it env and then activate it.

```
python -m venev env
```

To activate it, should access PowerShell, and Run as administrator and try to activate it, in our case we run

```
env/Scripts/activate
```

Now you can install the requirements

```
pip install -r requirements.txt
```

Then you can configure our application by running these cmd lines. For Windows users use <b>set</b> otherwise use <b>export</b>.

```
set FLASK_APP=run.py
```

```
set FLASK_ENV=development
```

Now, let‚Äôs run our application

```
python -m flask run
```

This starts the service in debug mode, Running on http://127.0.0.1:5000/.

We recommend testing using Postman, so you can follow the data flow and test all the cases with using both endpoints http://127.0.0.1:5000/enocde, and http://127.0.0.1:5000/decode.<br>
Since for each request we are entering data JSON through the body. Thinking about putting the URL in the params can crash the flow due to the special characters one URL can have.

## üîß Running the tests <a name = "tests"></a>

For test automation, we used the unittest framework. When running the test you should keep the server running too, because when testing the Endpoints we are sending requests to check if we get the desired response or not.
To run all the tests, try this line

```
python -m unittest discover test
```

or to test each one apart at a time try:<br>
For testing randomGenerator

```
python -m unittest test/test_random_generator.py
```

To test url_repository:

```
python -m unittest test/test_url_repository.py
```

For API testing

```
python -m unittest test/test_url_controller.py
```

### Break down into end to end tests

To test our app, we made 3 test modules:

<ul>
<li><b>test urlRepository</b>: <br>
In these tests, we are checking for each helper function in the repository the output is valid or not. Naming some of the functions from the urlRepository:
<ul>
<li>is_exist_key/url: To check if the key or url exists in our storage or not to avoid duplications.
</li>
<li>get_short or get_long URL: The functions to get the needed URL, whether the short or the original URL from the storage and it existence should be tested first.</li>
<li>save_url: Using this function to check if the key and the url exists already in the storage then so nothing because it is saved, if the original url exists and comes along with a new custom key then we should update it and delete the old one. And in the ordinary case, the url and the key will be saved in the storage for future purposes. 
</li>
</ul>
Testing all these functions and more others by checking the input to be as expected.
</li>
<li><b>test randomGenerator</b>:<br>
In this unit test we are checking the function responsible for generating a random key, one of the test this function do is after generating a key, it check out if it does exist in the storage, if it does then it will keep on rolling until it receive an unique one, this is to ensure uniqueness and avoid conflict.<br>
When it comes to testing we are just testing the length of the generated key if it is equal that what we are asked to do. Testing at random is ridiculous because counting the probability of getting the same generated key is so low and it won't test the efficiency of the function.</li>
<li><b>test urlController</b>:<br>
In this case we are testing the two endpoints /encode, and /decode. For each endpoint, multiple test on how the system should behave in which case and what it should return as response and handling error, all of these features are tested. Listin some testing made for each endpoints:
<ul>
<li><b>/encode</b>:<br>
<ol>
<li>Test with Valid long URL that should return Ok, after being saved in the storage.</li>
<li>Test with valid long URL, and custom key that should also return OK, 200. </li>
<li>Test with an empty long URL, should return BAD REQUEST, 400.</li>
<li>Test with an unvalid long URL, should return BAD REQUEST, 400.</li>
<li>...</li>
</ol>
</li>
<li><b>/decode</b>:<br>
<ol>
<li>Test with existing short URL that should return Ok, after returning the associated Original URL.</li>
<li>Test with an empty short URL, should also return BAD REQUEST, 400. </li>
<li>Test with non existing short URL, should return NOT FOUND, 404.</li>
<li>Test with an unvalid short URL, should return BAD REQUEST, 400.</li>
</ol>
</li>
</ul>
</li>
</ul>

## üéà Quick note and Demo about running the test <a name="usage"></a>

<p>A quick note about unit test, when testing the update feature of an existing long URL with custom key, it will show 404 NOT FOUND at first so one unit test will fail at the first try which is OKAY, in this case. Because we are testing if th long URL exist while we still don't have storage yet. Which explain why all the tests pass in the second try because the URL we are testing with is now stored so it is FOUND, and then updated so it will return 200, OK.<br>
Let's count it as a test for the unit test and it shows that it is a trustworthy enough XD.</p>

- [Demo](https://drive.google.com/file/d/1YXx0niJElaA0VZh8yPwaplXtOnuN-XGs/view?usp=drivesdk)

## Folder/file Structure <a name="folder/file_structure"></a>

### Structure Scheme

Following best practices advices, this is how we structured our Application.

```
__ APP
 |
 |__ app
 |        |__ controller
 |              |__ Url_controller.py
 |
 |        |__ repository
 |              |__ Database.py
 |              |__ Url_repository.py
 |
 |        |__ util
 |              |__ Random_generator.py
 |
 |        |__ __init__.py
 |
 |__ env
 |
 |__ test
 |        |__ test_random_generator.py
 |        |__ test_url_controller.py
 |        |__ test_url_repository.py
 |
 |__ README.md
 |__ requirements.txt
 |__ run.py
```

### Understanding the Folder/File structure

```
app : Holds all application folders and files.
```

```
app > controller : Contains the controllers, it receives the requests and provides the response.
```

```
app > repository : Contains the Database Module and Url_repository module, it communicate with the data storage directly and contain all all the helper function and database checks.
```

```
app > util : Contains the url_generator Module, which is the logic of our service.
```

```
app > __init__ : Used to mark directory on disk as Python package directory.
```

```
app > env : Generated when creating a virtual enviorement.
```

```
app > test : Contain all the testing modules, and with test_* for the naming.
```

```
app > requirements.txt : Lists not only the packages necessary to run the code but also registers their respective versions.
```

```
app > run.py : The entry point of our project.
```

## ‚õèÔ∏è Built Using <a name = "built_using"></a>

- [Flask](https://palletsprojects.com/p/flask/) - Web application Framework.
- [unittest](https://docs.python.org/3/library/unittest.html) - Unit testing framework.

## üñêüñêüñê Demo Link <a name = "demo_link"></a> üñêüñêüñê

- [Drive link](https://drive.google.com/file/d/1YX9CW4xvcUceAexHvGVMe2-Ety9FxeUL/view?usp=sharing)

## ‚úçÔ∏è Candidate <a name = "candidate"></a>

- [@EyaAbbassi](https://www.linkedin.com/in/eya-abbassi/)
- [Leetcode-Account](https://leetcode.com/Eya_Abbassi/)
- [Github-Account](https://github.com/EyaAbbassi)

## üéâ Acknowledgements <a name = "acknowledgement"></a>

- So much appreciation to [FINN.auto](https://www.finn.auto/), for giving me this opportunity to expand my knowledge and challenge myself within a range of time. And Thanks to The FINN GmbH Team for taking the time to evaluate my humble work.
- Hat tip to [Uncle Bob](https://fr.wikipedia.org/wiki/Robert_C._Martin), who taught us a lot about clean code and best practices.
- To all the programmers who post resources on the Internet, you are inspiring and supporting us.
- To [Leetcode](leetcode.com), with which I improved my problem solving skills and became better at Data Structures and Algorithms.

<p align="center">
  <a href="" rel="noopener">
 <img width=200px height=200px src="https://smsmagic-13d6c.kxcdn.com/wp-content/uploads/2021/01/Shorten-URL-1024x635.png" alt="URL shortening service"></a>
</p>

<h3 align="center">URL Shortening Service</h3>

---

<p align="center"> <b>Let's design a servicefor shortening the uniform resource locator (URL)</b>
    <br> 
   URL shortening is a service that produces short aliases for long URLs, commonly referred to as short links. Upon clicking, these short links direct to the original URLs.
</p>

## üìù Table of Contents

- [About](#about)
- [System Design](#system_design)

## üßê About <a name = "about"></a>

<p>In this application, we'll use <b>Flask</b> with <b>Python</b> to create a URL shortener. The service takes any given URL and generates a shorter, more readable version. To spice things up, the app lets users enter a URL and an optional custom short key, and generates a shorter version accordingly.
</p>
### Advantages
 
The key advantages of a URL shortening service are:
 
<ul>
<li>
Shortened URLs are convenient to use: they optimize link usage across different forms of devices due to their enhanced accessibility and non-breakability.
</li>
<li>They are visually professional and engaging and facilitate a higher degree of sharing possibilities.</li>
<li>They are less error-prone while typing.</li>
<li>They require smaller storage space at the user‚Äôs end.</li>
</ul>
 
### Disadvantages
The URL shortening service has some associated drawbacks as well. Some of them are as follows:
 
<ul>
<li>
We lose the originality of our brand. Many brands using the same service get short URLs containing the same domain.
</li>
<li>The possibility of it getting shut down and wiping all our shortened URLs will always be there.</li>
</ul>
 
## üöÄ System Design <a name = "system_design"></a>
 
Before jumping into development, we took the time to focus on the <b>Requirements</b> [<i>the functional and non-functional requirements</i>], for more clarity, it is better to have realistic estimations at the start. For instance, we don't have a lot to tell at this point but I am willing to learn more in depth about it. Yet we recongnize the importance of this step for the future of the service, from Storage estimation, to Query rate estimation, Bandwidth estimation, then Memory estimation, to finally estimate the Number of Servers. According to this challenge we were asked to not persist short URLs to a database. and just keep them in memory. For that reason, we will be using Hashmap to store in the memory, which is the most accurate and efficient data structure in this case.
Next, to fill up the whole big picture, more explanation about the <b>Design</b> should take place, to check the endpoints and the data flow between components. In case we are escalating, we can always return and adjust it from there.
Now, we can dive deeper, through the inner mechanism of the <b>Encode</b>, stating the reason we use it along with the mathematical explanation. Finally, we can reflect on all of that with a <b>conclusion</b> and add the area of improvement. Due to the restriction of time.<br>
<i>Funny but honest fact, it is my first time working on web development using Python, I usually use python for coding, data structures and Algorithms and creating notebook for machine learning and research purpose. Yet, I enjoyed every second working on this project and walking through the System design phase helped me a lot implementing the solution, which will be always open to improvement.</i><br>
Now let's drive into details:
### Requirements of shortening service
#### Functional requirements
<ul>
<li><b>Generate Short URL</b>: From an Original URL, generate a unique shorter key to create a shorter URL. </li>
<li><b>Reverse</b>: Given a short link, our system should return the Original URL.</li>
<li><b>Custom short links</b>: Users should be able to generate custom short links by giving a custom key.</li>
<li><b>Update short links</b>: After getting a generated short URL from our service, users can update their short links by giving a custom key.</li>
<li><b>Deletion</b>: Once the short link is updated, our service frees the memory to avoid confusion and wasted space due to duplication.</li>
</ul>

#### Non-functional requirements

<ul>
<li><b>Availability</b>: Our system should be highly available. </li>
<li><b>Scalability</b>: Our system should be horizontally scalable with increasing demand.</li>
<li><b>Readability</b>: The short links generated by our system should be easily readable, distinguishable, and typeable.</li>
<li><b>Latency</b>: The system should perform at low latency to provide the user with a smooth experience.</li>
<li><b>Unpredictability</b>:  From a security standpoint, the short links generated by our system should be highly unpredictable. </li>
</ul>

### Design

#### System APIs

To expose the functionality of our service, we can use REST APIs for the following endpoints:
/encode
/decode

##### Encode

To encode the original URL and create a unique short one, we sent a POST request with body containing:

<ul>
<li><b>‚Äúlong_url‚Äù-Required</b>: The original long URL that is needed to be shortened.</li>
<li><b>‚Äúcustom_id‚Äù-Optional</b>: The optional key that the user defines as a customer short key for the new URL.</li>
</ul>
<p>
A successful insertion returns a JSON with the shortened URL. If the input URL already stored but we got a custom_id as an input, here is when a user try to update the stored generate Short URL. In this case, we update the corresponding Short URL and Delete this old one. Otherwise, the system returns an appropriate error code to the user.
</p>

##### Decode

To decode a short URL and get the original one, we sent a GET request with body containing:

<ul>
<li><b>‚Äúshort_url‚Äù-Required</b>: The original long URL that is needed to be shortened.</li>
</ul>
<p>
A successful request returns a JSON with the original URL. Otherwise, the system returns an appropriate error code to the user.
</p>

#### Work flow

Let‚Äôs analyze the system in-depth and how the individual pieces fit together to provide the overall functionality.<br>
Keeping in view the functional requirements, the workflow of the abstract design above would be as follows.

<ol>
<li>
<b>Encode</b>: Each new request for short link computation checks the storage units (caching system and database) .
If the input exists already two cases raise:<br>
If the custom_key is not empty, update the associated short_url accordingly and delete the old one. Else, just return the existing short_url associated to the original URL.<br>
Else, generate a random key to create a unique short url for the input URL. Upon successful generation of the short link, the system sends one copy back to the user and stores the record in the database for future use.<br>
<i>In our case we store it to a hashmap with long_url as key and the generated_short_url as a value. For future use we should also store the generated/cutom_key as a key in another hashmap with the original_url as a value.
</i>

<li>
<b>Custom short links</b>: This task begins with checking the length, the maximum length allowed is 8 alphanumeric digits. Once verified, the system checks its availability in the database. If the requested cutom_key doesn‚Äôt exist, the user receives a successful short URL, or an error message in the opposite case.
</li>

<li>
<b>Decode</b>: Upon receiving the decode request, check the storage units (caching system and database) for the required record of the short url. If found, the application server returns the associated original URL.<br>
<i>Here we need the second hashmap with generated/cutom_ key as a key and the original_url as a value. The access/search will cost less -O(1) for time complexity.</i>
</li>

### Encode

The main functionality of our service is to generate a unique key to create a short URL. The encoding choice is so important to check on some of the non-functional requirements mentioned above such as <b>Readability</b>, and <b>Unpredictability</b>.<br>
The number of characters of the key should always be updated according to the clients‚Äô needs.<br>
Base-64 is the most common encoding for alphanumeric strings' generation. However, the generated short URL might have readability issues because of look-alike characters, and characters like + and / should be avoided because of other system-dependent encodings.
Since we don‚Äôt have any restriction about how we can encode, we can go with using Python‚Äôs random module and in-built string module for letters(lower and upper) and digits.

### Conclusion

Our service is an effective service with multiple advantages. Our design of the URL shortening service is simple, yet it fulfills all the requirements of a performant design. The key features offered by our design are:

<ul>
<li>A dynamic short URL range.</li>
<li>Improved readability.</li>
</ul><br>

<b>Area of improvement</b>:<br>

<ul>
<li>- More restriction on the custom_key suggested by the users to avoid special characters, and condused Links.</li>
<li>- Upgrade the encoding method toensure security by adding the user_id which is private and unique as encoding key for example that we can use with other Encoding Algorithm such as Advanced Encryption Standard (AES).</li>
<li>- Add more control on the generated short URL, that must always be shorter or equal than the original one. It won't be a shortening service if we will give a taller "short_url".</li>
<li>...Always open to improve and escalate according to the business and clients/users needs.</li>
</ul>
